#include <iostream>

int sub(int a, int b); // forward declaration
// int add(int, int); // Теж валідний запис, але краще вписати назви аргументів щоб не плутатися

int add(int x, int y) {
    return x + y;
}

/**
 * Оскільки параметр, який не передається у функцію не використовується, то можна лишити його без імені,
 * лише вказавши тип даних. Також можемо в тому ж рядку вказати коментар, що це за параметр
 *
 * Навіщо таке може знадобитися?
 * Припустимо, ми маємо функцію з одним параметром. Пізніше функція оновлюється певним чином, і значення параметра більше не потрібне.
 * Якщо б просто видалити параметр функції, який тепер не використовується, то всі існуючі виклики функції перестали
 * б працювати (оскільки виклик функції надавав би більше аргументів, ніж функція могла б прийняти). Це вимагало б від нас
 * знайти кожен виклик функції і видалити непотрібний аргумент. Це може бути дуже трудомістким завданням (і вимагати багато повторних тестувань).
 * Це також може бути навіть неможливим (у випадках, коли ми не контролюємо весь код, що викликає функцію).
 * Тому замість цього ми можемо залишити параметр як є і просто зробити так, щоб він нічого не робив.
 */
int multiple(int /*count*/) {
    int res{2*2};
    return res;
}

int main() {
    // int sum {add(1,"2")}; // compile error
    int sum {add(1,2)};
    int square2 {multiple(1)};

    std::cout << "Sum: " << sum << std::endl;


    // Temporary file

    std::cout << "Sum: " << add(1,2) << std::endl;

    /**
     * У прикладі вище ви викликали add(1,2). У середині цієї функції відбулися якісь
     * дії і повернулося значення, однак після того, як функція add вфдпрацює, то всі її
     * змінні будуть видалені (параметри і внутрішні локальні змінні), тоді де зберігається
     * результат який функція повернула?
     *
     * Він зберігається у Temporary objects - це анонімні об'єкти, які не мають назви і будуть
     * знищені перед виконанням наступної операції (Як би після ::cout був би новий рядок, де
     * робилася би якась операція, то на ньому Temporary objects який зберігав результат add
     * був би вже знищений
     *
     *
     * У сучасній мові C (особливо починаючи з C 17) компілятор має багато хитрощів, щоб уникнути
     * створення тимчасових змінних там, де раніше це було б необхідно, зараз компілятор просто
     * ініціалізує змінну безпосередньо поверненим значенням (return value)
     * Тобто
     * int result {add(1,2)} - add() поверне дані безпосередньо у result, без створення тимчасового об'єкта
     *
     */

    // Оскільки функція sub була написана нижче main то компілятор на рядку 57 ще не знає за її існування
    // Саме тому треба або написати sub вище за main, або зробити forward declaration
    // Це коли ми напишемо int sub(int a, int b); на верху файлу. Це покаже компілятору, що sub це функція і вона існує,
    // це ункція яка приймає два параметри і повертає int
    int sub_result {sub(3,5)}; // Видасть помилку: error: 'sub' was not declared in this scope;
    std::cout << "Sub result is: " << sub_result << std::endl; // Sub result is: -2


    return 0;
}

int sub(const int a, const int b) {
    return  a - b;
}


/**
 * Це буде працювати нормально, оскільки функція add2() з трьома параметрами
 * визначена перед main, а функція add2() з двома параметрами має лише declaration,
 * а не definition (не написана сама функція), але вона ніколи і не викликається, тож і
 * помилки не буде
 *
 */
int add2(int x, int y);

int add2(int x, int y, int z){
    return x + y + z;
}

int main2()
{
    std::cout << "3 + 4 + 5 = " << add2(3, 4, 5) << '\n';
    return 0;
}